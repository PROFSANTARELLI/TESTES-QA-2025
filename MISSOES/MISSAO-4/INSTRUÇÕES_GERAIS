MISSÃO 4: VALOR AC: 0,50 PT - bônus de mais 0,25 na PROVA SEMESTRAL se atingir sucesso de 100%
OBJETIVO: MONTAR FLUXO DE TESTE DE UM SISTEMA Gerenciador Financeiro Pessoal simples. Cada exercício adicionará uma nova funcionalidade e os testes correspondentes.

Estrutura Básica de projeto:
gerenciador_financeiro/
├── .github/
│   └── workflows/
│       └── ci_fase2.yml
├── src/
│   ├── __init__.py
│   └── core.py
├── tests/
│   ├── __init__.py
│   └── test_core.py
└── requirements.txt

Exercício 1: Criando e Validando uma Despesa
Objetivo: Aprender a testar a criação de objetos de dados, validar entradas e configurar o requirements.txt e o workflow inicial do GitHub Actions.

Passo 1: Código da Aplicação
Vamos usar a biblioteca Pydantic para criar um modelo de dados robusto para nossas despesas.
No arquivo src/core.py, adicione o seguinte código:
# src/core.py
from pydantic import BaseModel, Field, validator
from datetime import date

class Expense(BaseModel):
    """Representa uma única despesa."""
    id: int
    description: str = Field(min_length=3)
    amount: float = Field(gt=0) # gt=0 significa 'greater than 0'
    category: str
    date: date

    @validator('category')
    def category_must_be_valid(cls, v):
        """Valida se a categoria não está vazia."""
        if not v.strip():
            raise ValueError("A categoria não pode ser vazia")
        return v

Passo 2: Configurando as Dependências
No arquivo requirements.txt, adicione as bibliotecas que nosso projeto usará:
# requirements.txt
pydantic
pytest

Passo 3: Escrevendo os Testes Unitários
No arquivo tests/test_core.py, vamos testar nosso modelo Expense:
# tests/test_core.py
import pytest
from pydantic import ValidationError
from datetime import date
from src.core import Expense

def test_criar_despesa_valida():
    """Testa a criação de uma despesa com dados válidos."""
    expense = Expense(
        id=1,
        description="Café da manhã",
        amount=15.50,
        category="Alimentação",
        date=date(2025, 9, 21)
    )
    assert expense.id == 1
    assert expense.description == "Café da manhã"
    assert expense.amount == 15.50

def test_nao_criar_despesa_com_valor_negativo():
    """Testa que uma despesa não pode ser criada com valor negativo ou zero."""
    with pytest.raises(ValidationError) as excinfo:
        Expense(id=2, description="Invalido", amount=-100, category="Teste", date=date.today())
    # Verifica se a mensagem de erro da Pydantic informa sobre o valor
    assert "ensure this value is greater than 0" in str(excinfo.value)

def test_nao_criar_despesa_com_descricao_curta():
    """Testa que a descrição deve ter pelo menos 3 caracteres."""
    with pytest.raises(ValidationError):
        Expense(id=3, description="ab", amount=20, category="Teste", date=date.today())

def test_nao_criar_despesa_com_categoria_vazia():
    """Testa que a categoria não pode ser uma string vazia."""
    with pytest.raises(ValueError) as excinfo:
        Expense(id=4, description="Teste categoria", amount=50, category="   ", date=date.today())
    assert "A categoria não pode ser vazia" in str(excinfo.value)

Passo 4: Executando os Testes Localmente
Instale as dependências:
pip install -r requirements.txt
Rode os testes:
pytest
O resultado esperado é: 4 passed.

Passo 5: Configurando o Workflow do GitHub Actions
No arquivo .github/workflows/ci.yml, adicione o workflow inicial:

# .github/workflows/ci_fase2.yml
name: CI_fase de Testes Python

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.9", "3.10"]

    steps:
      - name: Checkout do código
        uses: actions/checkout@v3

      - name: Configurar Python ${{ matrix.python-version }}
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Rodar os testes
        run: pytest

Passo 6: Enviando para o GitHub
Enviem o código para um novo repositório no GitHub e verificarem a aba "Actions" para ver o workflow rodando e passando com sucesso.



Exercício 2: Gerenciando um Repositório de Despesas
Objetivo: Aprender a testar uma classe que gerencia o estado (uma coleção de objetos), simulando um banco de dados em memória.

Passo 1: Evoluindo o Código da Aplicação
Adicione a classe ExpenseRepository ao final do arquivo src/core.py:
# ... (classe Expense continua aqui) ...
class ExpenseRepository:
    """Gerencia uma coleção de despesas em memória."""
    def __init__(self):
        self._expenses: list[Expense] = []
        self._next_id: int = 1

    def add(self, expense_data: dict) -> Expense:
        """Adiciona uma nova despesa ao repositório."""
        # Cria uma instância do modelo Expense, que já valida os dados
        new_expense = Expense(id=self._next_id, **expense_data)
        self._expenses.append(new_expense)
        self._next_id += 1
        return new_expense

    def get_by_id(self, expense_id: int) -> Expense | None:
        """Busca uma despesa pelo seu ID."""
        for expense in self._expenses:
            if expense.id == expense_id:
                return expense
        return None

    def get_all(self) -> list[Expense]:
        """Retorna todas as despesas."""
        return self._expenses

Passo 2: Escrevendo os Novos Testes
Adicione estes testes ao final do arquivo tests/test_core.py:
# ... (testes anteriores continuam aqui) ...
@pytest.fixture
def repo():
    """Cria uma instância limpa do repositório para cada teste."""
    return ExpenseRepository()

def test_adicionar_despesa_ao_repositorio(repo):
    """Testa se uma despesa é adicionada corretamente e recebe um ID."""
    expense_data = {
        "description": "Almoço", "amount": 35.0, "category": "Alimentação", "date": date.today()
    }
    new_expense = repo.add(expense_data)
    
    assert new_expense.id == 1
    assert len(repo.get_all()) == 1
    assert repo.get_by_id(1) == new_expense

def test_buscar_despesa_por_id_existente(repo):
    """Testa a busca de uma despesa que existe."""
    expense_data = {"description": "Cinema", "amount": 50.0, "category": "Lazer", "date": date.today()}
    repo.add(expense_data)
    
    found_expense = repo.get_by_id(1)
    assert found_expense is not None
    assert found_expense.id == 1
    assert found_expense.description == "Cinema"

def test_buscar_despesa_por_id_inexistente(repo):
    """Testa a busca de uma despesa que não existe."""
    assert repo.get_by_id(999) is None

def test_adicionar_multiplas_despesas_incrementa_id(repo):
    """Testa se os IDs são auto-incrementados corretamente."""
    repo.add({"description": "Uber", "amount": 22.0, "category": "Transporte", "date": date.today()})
    repo.add({"description": "Livro", "amount": 80.0, "category": "Educação", "date": date.today()})
    
    despesa_2 = repo.get_by_id(2)
    assert len(repo.get_all()) == 2
    assert despesa_2 is not None
    assert despesa_2.description == "Livro"

Conceito novo: pytest.fixture é usado para criar e fornecer um objeto (repo) para as funções de teste, garantindo que cada teste comece com um repositório limpo.

Passo 3: Rodar, Atualizar e Verificar
Rode os testes localmente com pytest. O resultado esperado é: 8 passed.
Envie as alterações para o GitHub.
Verifique na aba "Actions" que o workflow continua passando com os novos testes.


Exercício 3: Implementando Lógica de Negócio e Mocking
Objetivo: Aprender a testar uma classe de serviço que depende de outra (o repositório), usando mocks para isolar a unidade que está sendo testada.
Passo 1: Evoluindo o Código da Aplicação
Adicione a classe FinancialManager ao src/core.py. Esta classe usará o ExpenseRepository.
# ... (classes Expense e ExpenseRepository continuam aqui) ...
class FinancialManager:
    """Gerencia as operações financeiras, usando um repositório."""
    def __init__(self, repository: ExpenseRepository):
        self._repository = repository

    def add_expense(self, expense_data: dict) -> Expense:
        """Adiciona uma nova despesa através do repositório."""
        # Delega a criação e armazenamento para o repositório
        return self._repository.add(expense_data)

    def get_total_expenses(self) -> float:
        """Calcula o valor total de todas as despesas."""
        all_expenses = self._repository.get_all()
        return sum(expense.amount for expense in all_expenses)```

#### **Passo 2: Atualizando as Dependências**
Precisaremos da biblioteca `pytest-mock` para facilitar o uso de mocks. Adicione-a ao `requirements.txt`:
```txt
pydantic
pytest
pytest-mock # Adicionar esta linha

Passo 3: Escrevendo os Testes com Mocks
No arquivo tests/test_core.py, adicione os seguintes testes. Note que não usaremos a fixture repo aqui, pois vamos simular (mockar) o repositório.
# ... (testes anteriores continuam aqui) ...
from src.core import FinancialManager

def test_financial_manager_adiciona_despesa(mocker):
    """Testa se o FinancialManager chama corretamente o método add do repositório."""
    # Cria um mock do repositório
    mock_repo = mocker.MagicMock(spec=ExpenseRepository)
    manager = FinancialManager(repository=mock_repo)
    
    expense_data = {"description": "Jantar", "amount": 120.0, "category": "Alimentação", "date": date.today()}
    manager.add_expense(expense_data)
    
    # Verifica se o método 'add' do mock foi chamado exatamente uma vez com os dados corretos
    mock_repo.add.assert_called_once_with(expense_data)

def test_get_total_expenses_com_varias_despesas(mocker):
    """Testa o cálculo do total de despesas, usando um repositório mockado."""
    mock_repo = mocker.MagicMock(spec=ExpenseRepository)
    # Configura o valor de retorno do mock
    mock_repo.get_all.return_value = [
        Expense(id=1, description="a", amount=10.50, category="c", date=date.today()),
        Expense(id=2, description="b", amount=20.00, category="c", date=date.today()),
        Expense(id=3, description="c", amount=0.50, category="c", date=date.today()),
    ]
    
    manager = FinancialManager(repository=mock_repo)
    total = manager.get_total_expenses()
    
    assert total == 31.00

def test_get_total_expenses_sem_despesas(mocker):
    """Testa o cálculo do total quando não há despesas."""
    mock_repo = mocker.MagicMock(spec=ExpenseRepository)
    mock_repo.get_all.return_value = [] # Retorna uma lista vazia
    
    manager = FinancialManager(repository=mock_repo)
    total = manager.get_total_expenses()
    
    assert total == 0.0

Conceito novo: mocker é uma fixture do pytest-mock. mocker.MagicMock cria um objeto falso que registra como foi usado. Podemos então verificar se métodos (add) foram chamados (assert_called_once_with) ou definir o que eles devem retornar (return_value).

Passo 4: Rodar, Atualizar e Verificar
Instale a nova dependência: pip install -r requirements.txt.
Rode os testes: pytest. O resultado esperado é: 11 passed.
Envie as alterações para o GitHub e verifique o workflow.


Exercício 4: Testes Parametrizados
Objetivo: Aprender a usar a parametrização do Pytest para rodar o mesmo teste com diferentes entradas e saídas, reduzindo a repetição de código.
Passo 1: Evoluindo o Código da Aplicação
Vamos adicionar um método para categorizar as despesas por nível de custo. Adicione este método à classe FinancialManager em src/core.py:
# ... (dentro da classe FinancialManager) ...
    def categorize_expense_by_cost(self, expense: Expense) -> str:
        """Categoriza uma despesa como 'Baixo', 'Médio' ou 'Alto' custo."""
        if expense.amount <= 20.0:
            return "Baixo"
        elif 20.0 < expense.amount <= 100.0:
            return "Médio"
        else:
            return "Alto"

Passo 2: Escrevendo Testes Parametrizados
Adicione este teste ao tests/test_core.py. Ele substitui o que seriam três testes separados.
# ... (testes anteriores continuam aqui) ...
@pytest.mark.parametrize(
    "amount, expected_category",
    [
        (15.0, "Baixo"),     # Teste 1: Custo baixo
        (20.0, "Baixo"),     # Teste 2: Custo baixo (limite)
        (20.01, "Médio"),    # Teste 3: Custo médio (acima do limite)
        (100.0, "Médio"),    # Teste 4: Custo médio (limite)
        (100.01, "Alto"),    # Teste 5: Custo alto (acima do limite)
        (5000.0, "Alto"),    # Teste 6: Custo alto
    ]
)
def test_categorize_expense_by_cost(amount, expected_category):
    """Testa a categorização por custo com diferentes valores."""
    manager = FinancialManager(repository=None) # Não precisamos de repo aqui
    expense = Expense(id=1, description="Teste", amount=amount, category="cat", date=date.today())
    
    result = manager.categorize_expense_by_cost(expense)
    
    assert result == expected_category

Conceito novo: @pytest.mark.parametrize permite definir uma lista de argumentos de entrada (amount) e os resultados esperados (expected_category). O Pytest executará a função de teste uma vez para cada tupla na lista.

Passo 3: Rodar, Atualizar e Verificar
Rode os testes: pytest -v. O -v (verbose) mostrará que 6 testes passaram para test_categorize_expense_by_cost. O total será 17 passed.
Envie as alterações e verifique o workflow no GitHub.



Exercício 5: Mockando Requisições HTTP Externas
Objetivo: Aprender a testar código que depende de uma API externa, usando mocks para simular respostas HTTP e evitar que os testes dependam da internet.

Passo 1: Evoluindo o Código da Aplicação
Vamos criar uma função que converte o valor de uma despesa para Dólar, consumindo uma API de cotação fictícia. Adicione ao final de src/core.py:

# ... (resto do código) ...
import requests

def get_expense_in_usd(expense: Expense) -> float | None:
    """
    Converte o valor de uma despesa para USD usando uma API externa.
    A API fictícia é: https://api.exchangerate-api.com/v4/latest/BRL
    """
    try:
        response = requests.get("https://api.exchangerate-api.com/v4/latest/BRL")
        response.raise_for_status()  # Lança uma exceção para erros HTTP (4xx ou 5xx)
        
        data = response.json()
        usd_rate = data["rates"]["USD"]
        
        return round(expense.amount * usd_rate, 2)
    except requests.exceptions.RequestException:
        return None
    except (KeyError, TypeError):
        return None # Caso a resposta da API venha em um formato inesperado

Passo 2: Atualizando as Dependências
Precisamos das bibliotecas requests para fazer a chamada HTTP e responses para mocká-la nos testes. Atualize o requirements.txt:
pydantic
pytest
pytest-mock
requests      # Adicionar esta linha
responses     # Adicionar esta linha

Passo 3: Escrevendo os Testes para a API
Adicione estes testes ao tests/test_core.py:
# ... (testes anteriores continuam aqui) ...
import responses
from src.core import get_expense_in_usd

@responses.activate
def test_get_expense_in_usd_sucesso():
    """Testa a conversão para USD quando a API responde com sucesso."""
    # 1. Mock da resposta da API
    responses.add(
        responses.GET,
        "https://api.exchangerate-api.com/v4/latest/BRL",
        json={"rates": {"USD": 0.20}}, # Cotação fictícia: 1 BRL = 0.20 USD
        status=200
    )
    
    expense = Expense(id=1, description="Teste", amount=100.0, category="cat", date=date.today())
    
    # 2. Executa a função
    usd_amount = get_expense_in_usd(expense)
    
    # 3. Verifica o resultado
    assert usd_amount == 20.00 # 100.0 * 0.20

@responses.activate
def test_get_expense_in_usd_api_falha():
    """Testa o comportamento quando a API retorna um erro 500."""
    # Mock de uma resposta de erro
    responses.add(
        responses.GET,
        "https://api.exchangerate-api.com/v4/latest/BRL",
        status=500
    )
    
    expense = Expense(id=1, description="Teste", amount=100.0, category="cat", date=date.today())
    
    usd_amount = get_expense_in_usd(expense)
    
    assert usd_amount is None

@responses.activate
def test_get_expense_in_usd_formato_invalido():
    """Testa o comportamento quando a API retorna um JSON inesperado."""
    # Mock de uma resposta com formato inválido (faltando a chave 'rates')
    responses.add(
        responses.GET,
        "https://api.exchangerate-api.com/v4/latest/BRL",
        json={"invalid_key": "some_value"},
        status=200
    )
    
    expense = Expense(id=1, description="Teste", amount=100.0, category="cat", date=date.today())
    
    usd_amount = get_expense_in_usd(expense)
    
    assert usd_amount is None

Conceito novo: A biblioteca responses intercepta chamadas feitas pela biblioteca requests. @responses.activate ativa esse interceptador. responses.add permite definir qual será a resposta simulada para uma determinada URL e método HTTP.

Passo 4: Rodar, Atualizar e Verificar
Instale as novas dependências: pip install -r requirements.txt.
Rode os testes: pytest. O total será 20 passed.
Envie as alterações para o GitHub.

Verifique o workflow na aba "Actions". Ele agora instalará todas as dependências e rodará todos os 20 testes com sucesso.
